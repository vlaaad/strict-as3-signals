<#assign params = params!>
<#assign name = name!>
<#assign package = package!>
/**
 * WARNING: THIS FILE IS AUTOGENERATED!
 */
package ${package} {

<#if params?has_content>
    <#assign argNames = params?keys>
    <#list argNames as arg>
        <#assign dispatchClass = params[arg]>
        <#if dispatchClass?split(".")?size != 1 >
import ${params[arg]};
        </#if>
    </#list>
</#if>

public class ${name?cap_first}Signal {
	private var _head:Node;
	private var _tail:Node;

	public function ${name?cap_first}Signal() {

	}

	public function add(listener:I${name?cap_first}Handler):void {
		register(listener, false);
	}

	public function addOnce(listener:I${name?cap_first}Handler):void {
		register(listener, true);
	}

	private function register(listener:I${name?cap_first}Handler, once:Boolean):void {
		var node:Node = getNode(listener);
		if (node) {
			if (node.once) throw new Error("Illegal operation: adding listener that was added once");
			return;
		}
		node = new Node(listener, once);
		if (_tail) {
			_tail.next = node;
			_tail = node;
		} else {
			_head = node;
			_tail = node;
		}
	}

	public function remove(listener:I${name?cap_first}Handler):void {
		var node:Node = _head;
		var prev:Node = null;
		while (node) {
			if (node.listener == listener) {
				removeNode(prev, node);
			}
			prev = node;
			node = node.next;
		}
	}

	public function clear():void {
		_head = null;
		_tail = null;
	}

	public function has(listener:I${name?cap_first}Handler):Boolean {
		return getNode(listener) != null;
	}

	private function getNode(listener:I${name?cap_first}Handler):Node {
		var node:Node = _head;
		while (node) {
			if (node.listener == listener) return node;
			node = node.next;
		}
		return null;
	}

	private function removeNode(prev:Node, node:Node):void {
	    if (prev) {
	        if (node.next) {
                prev.next = node.next;
	        } else {
                prev.next = null;
                _tail = prev;
	        }
	    } else {
	        if (node.next) {
                _head = node.next;
	        } else {
	            _head = null;
	            _tail = null;
	        }
	    }
	}

	public function dispatch(<#if params?has_content><#list argNames as arg>${arg}:${params[arg]}<#if arg_has_next>, </#if></#list></#if>):void {
		var node:Node = _head;
		var prev:Node = null;
		while (node) {
			node.listener.handle${name?cap_first}(<#if params?has_content><#list argNames as arg>${arg}<#if arg_has_next>, </#if></#list></#if>);
			if (node.once) {
				removeNode(prev, node);
			}
			prev = node;
			node = node.next;
		}
	}
}
}

import ${package}.I${name}Handler;

class Node {
	public var next:Node;
	public var listener:I${name?cap_first}Handler;
	public var once:Boolean;

	public function Node(listener:I${name?cap_first}Handler, once:Boolean) {
		this.listener = listener;
		this.once = once;
	}
}